#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
.. module:: fileio.py
   :platform: Unix
   :synopsis: Reads the meta data of a tomographic hdf5 file and generates a table (rst) compatible with sphynx/readthelogs.

"""

import os
import sys
import time
import argparse
import numpy as np
import pandas as pd
import dxchange
import tomopy
import h5py
import matplotlib.pyplot as plt
from matplotlib.colors import NoNorm

from datetime import datetime

from mosaic import log
from mosaic import config
from mosaic import fileio
from mosaic import mosaic 
from mosaic import util

def init(args):
    if not os.path.exists(str(args.config)):
        config.write(str(args.config))
    else:
        raise RuntimeError("{0} already exists".format(args.config))

def status(args):
    config.show_config(args)

def extract(args):
    meta_dict = fileio.extract(args)
    for k, v in meta_dict.items():
        log.info("%s, %s, %s. Original file name: %s", k, meta_dict[k]['sample_x'], meta_dict[k]['sample_y'], meta_dict[k]['full_file_name'][0])

def sort(args):
    meta_dict = fileio.sort(args)
    for k, v in meta_dict.items():
        log.info("%s, %s, %s. Original file name: %s", k, meta_dict[k]['sample_x'], meta_dict[k]['sample_y'], meta_dict[k]['full_file_name'][0])

def tile(args):
    tile_dict, grid, data_shape, x_shift, y_shift = fileio.tile(args)
    proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[0,0], proj=(0, 10))
    log.info('image   size (x, y) in pixels: (%d, %d)' % (proj0.shape[2], proj0.shape[1]))
    log.info('mosaic shift (x, y) in pixels: (%d, %d)' % (x_shift, y_shift))

    columns = [f'x_{num}' for num in range(grid.shape[0])]
    index = [f'y_{num}' for num in range(grid.shape[1])]
    log.info('mosaic file name grid:\n%s' % pd.DataFrame(grid, columns=columns, index=index))

def shift(args):

    # read files grid and retrieve data sizes
    tile_dict, grid, data_shape, x_shift, y_shift = fileio.tile(args)
    log.info('mosaic shift (x, y) in pixels: (%d, %d)' % (x_shift, y_shift))

    columns = [f'x_{num}' for num in range(grid.shape[0])]
    index = [f'y_{num}' for num in range(grid.shape[0])]
    
    [ntiles_h,ntiles_v] = grid.shape

    # threshold for selecting matching features. It is given in range (0..1): higher value yields more matching features, 
    #lower value yields less matching features but more accurate
    threshold = 0.4

    # find shifts in horizontal direction
    shifts_h = np.zeros([ntiles_v,ntiles_h,2], dtype=np.float32)    
    for iy in range(ntiles_v):    
        for ix in range(ntiles_h-1):
            proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[iy,ix], proj=(0, data_shape[0], data_shape[0]//8))
            proj1, flat1, dark1, _, _ = dxchange.read_dx(grid[iy,ix+1], proj=(0, data_shape[0], data_shape[0]//8))
            norm0 = tomopy.normalize(proj0, flat0, dark0)
            norm1 = tomopy.normalize(proj1, flat1, dark1)
            wx = int((norm0.shape[2] - x_shift)*1)
            shift = mosaic.register_shift_sift(norm1[:,:,-wx:], norm0[:,:,:wx],threshold)
            shift = shift[~np.isnan(shift[:,0])]
            shifts_h[iy,ix+1] = [np.median(shift[:,0]),np.median(wx-shift[:,1])]            
    
    # find shifts in vertical direction
    shifts_v = np.zeros([ntiles_v,ntiles_h,2], dtype=np.float32)    
    for ix in range(ntiles_h):
        for iy in range(ntiles_v-1):            
            proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[iy,ix], proj=(0, data_shape[0], data_shape[0]//8))
            proj1, flat1, dark1, _, _ = dxchange.read_dx(grid[iy+1,ix], proj=(0, data_shape[0], data_shape[0]//8))
            norm0 = tomopy.normalize(proj0, flat0, dark0)
            norm1 = tomopy.normalize(proj1, flat1, dark1)
            wy = int((norm0.shape[1] - y_shift)*1)
            shift = mosaic.register_shift_sift(norm0[:,-wy:,:], norm1[:,:wy,:],threshold)
            shift = shift[~np.isnan(shift[:,0])]
            shifts_v[iy+1,ix] = [np.median(wy-shift[:,0]),np.median(shift[:,1])]

    log.info('Horizontal shifts')
    log.info(shifts_h)
    log.info('Vertical shifts')
    log.info(shifts_v)

    # save shifts
    # VN:we can try to save them as txt or csv instead to be able to change manually at any time
    log.info('save shifts as npy')
    np.save('/local/data/tmp/shifts_h.npy',shifts_h)
    np.save('/local/data/tmp/shifts_v.npy',shifts_v)
    return shifts_h, shifts_v

def stitch(args):
    
    #VN:should come from command line
    args.test = False # if test==True then 1 projection will be stitched and placed in /local/data/tmp/res_proj/r
    args.chunk_size = 64 # number of projections for simultaneous processing

    # read shifts
    shifts_h = np.load('/local/data/tmp/shifts_h.npy')
    shifts_v = np.load('/local/data/tmp/shifts_v.npy')
    
    # compute cumulative shifts
    cshifts_h = shifts_h[:,:,1]
    cshifts_v = shifts_v[:,:,0]
    cshifts_h[:,0] = np.cumsum(shifts_h[:,0,1]+shifts_v[:,0,1])
    cshifts_v[0,:] = np.cumsum(shifts_h[0,:,0]+shifts_v[0,:,0])
    cshifts_h = np.cumsum(cshifts_h,axis=1)
    cshifts_v = np.cumsum(cshifts_v,axis=0)

    # retrieve sizes (could be optimized)
    _, grid, data_shape, _, _ = fileio.tile(args)
    [ntiles_v,ntiles_h] = grid.shape
    proj0, flat0, dark0, theta0, _ = dxchange.read_dx(grid[0,0], proj=(0, 1))


    proj_size = (ntiles_v*data_shape[1]-int(cshifts_v[-1].max()), 
        (ntiles_h*data_shape[2]-int(cshifts_h[-1].max()))//4*4)#make the width divisible by 4 to work with binning 2 at least
    
    # number of projections to test stitching
    if(args.test==True):
        nproj_to_stitch = 1
        norm = np.zeros([nproj_to_stitch,*proj_size],dtype='float32')        
    else:
        nproj_to_stitch = data_shape[0]

    with h5py.File('/local/data/tmp/res.h5','w') as fid:
        # init output arrays
        proj = fid.create_dataset('/exchange/data', (nproj_to_stitch,*proj_size),dtype=proj0.dtype, chunks = (1,*proj_size))
        flat = fid.create_dataset('/exchange/data_white', (flat0.shape[0],*proj_size),dtype=flat0.dtype, chunks = (1,*proj_size))
        dark = fid.create_dataset('/exchange/data_dark', (dark0.shape[0],*proj_size),dtype=dark0.dtype, chunks = (1,*proj_size))
        theta = fid.create_dataset('/exchange/theta', data = theta0/np.pi*180)
        
        # stitch projections by chunks
        for ichunk in range(int(np.ceil(nproj_to_stitch/args.chunk_size))):
            st_chunk = ichunk*args.chunk_size
            end_chunk = min((ichunk+1)*args.chunk_size,nproj_to_stitch)
            log.info('Processing projections: %d - %d' % (st_chunk, end_chunk))
            for iy in range(ntiles_v):    
                for ix in range(ntiles_h):

                    # VN: no need to read flat and dark fields for each chunk, should we use h5py[].. instead?
                    proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[iy,ix], proj=(st_chunk,end_chunk))
                    
                    # define index in x for proj (filling from the right side)
                    st_x0 = int(np.round(proj.shape[2]-(ix+1)*data_shape[2]+cshifts_h[iy,ix]))
                    end_x0 = st_x0+data_shape[2]            
                    
                    # define index in y for proj (filling from the top side)
                    st_y0 = int(np.round(iy*data_shape[1]-cshifts_v[iy,ix]))
                    end_y0 = st_y0+data_shape[1]            
                    
                    # crop to the proj size 
                    st_y = max(st_y0,0)
                    st_x = max(st_x0,0)
                    end_y = min(end_y0,proj.shape[1])
                    end_x = min(end_x0,proj.shape[2])
                                        
                    # define index in x for proj0
                    st_x0 = st_x-st_x0
                    end_x0 = proj0.shape[2]+end_x-end_x0
                    
                    # define index in x for proj0
                    st_y0 = st_y-st_y0                    
                    end_y0 = proj0.shape[1]+end_y-end_y0
                    
                    # fill array part
                    proj[st_chunk:end_chunk,st_y:end_y,st_x:end_x] = proj0[:,st_y0:end_y0,st_x0:end_x0]

                    if(ichunk==0): # flat and dark field can be filled once (VN: maybe we can move this code out of the loop)
                        flat[:,st_y:end_y,st_x:end_x] = flat0[:,st_y0:end_y0,st_x0:end_x0]
                        dark[:,st_y:end_y,st_x:end_x] = dark0[:,st_y0:end_y0,st_x0:end_x0]
                    
                    if(args.test==True):                
                        # fill the normalized array part
                        norm[st_chunk:end_chunk,st_y:end_y,st_x:end_x] = tomopy.normalize(proj0[st_chunk:end_chunk,st_y0:end_y0,st_x0:end_x0], 
                            flat0[:,st_y0:end_y0,st_x0:end_x0], dark0[:,st_y0:end_y0,st_x0:end_x0])                
                        # plot lines arround borders (not necessary in future)
                        norm[st_chunk:end_chunk,min(max(st_y-16,0),proj.shape[1]-1),st_x:end_x]=0
                        norm[st_chunk:end_chunk,min(max(st_y+16,0),proj.shape[1]-1),st_x:end_x]=0
                        norm[st_chunk:end_chunk,min(max(end_y-16,0),proj.shape[1]-1),st_x:end_x]=0
                        norm[st_chunk:end_chunk,min(max(end_y+16,0),proj.shape[1]-1),st_x:end_x]=0
                        
                        norm[st_chunk:end_chunk,st_y:end_y,min(max(st_x-16,0),proj.shape[2]-1)]=0
                        norm[st_chunk:end_chunk,st_y:end_y,min(max(st_x+16,0),proj.shape[2]-1)]=0
                        norm[st_chunk:end_chunk,st_y:end_y,min(max(end_x-16,0),proj.shape[2]-1)]=0
                        norm[st_chunk:end_chunk,st_y:end_y,min(max(end_x+16,0),proj.shape[2]-1)]=0

    log.info('Stitched h5 file is saved as /local/data/tmp/res.h5')
    if(args.test==True):
        dxchange.write_tiff_stack(norm,'/local/data/tmp/res_proj/r',overwrite=True)      
        log.info('Test results are saved to /local/data/tmp/res_proj/')

# def stitch(args):  
#     # load shifts
#     # frame = pd.read_csv()
#     shifts_v = np.load('shifts_v.npy')
#     # read some data to retrieve sizes
#     tile_dict, grid, data_shape, x_shift, y_shift = fileio.tile(args)
#     ntiles_h = grid.shape[1]
#     proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[0,0], sino=(0,1))               
    
#     # resulting stitched arrays
#     proj = np.zeros([data_shape[0],1,ntiles_h*data_shape[2]-np.sum(shifts_h[:,0])],dtype=proj0.dtype)
#     flat = np.zeros([flat0.shape[0],1,ntiles_h*data_shape[2]-np.sum(shifts_h[:,0])],dtype=flat0.dtype)
#     dark = np.zeros([dark0.shape[0],1,ntiles_h*data_shape[2]-np.sum(shifts_h[:,0])],dtype=dark0.dtype)

#     shifts_h = np.cumsum(np.pad(shifts_h,((1,0),(0,0)),'constant'),axis=0)
#     print(f'{shifts_h=}')
#     for ix in range(ntiles_h):
#         # fill array with overlapping in the following way
#         # proj[end-n:end] = proj0
#         # proj[end-2*n+shift0:end-n+shift0] = proj1
#         # proj[end-3*n+shift1:end-2*n+shift1] = proj2
#         proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[0,ix], sino=(data_shape[1]//2-shifts_h[ix,1],data_shape[1]//2-shifts_h[ix,1]+1))#VN: looks like grid is filled from right to left!
#         st = proj.shape[2]-(ix+1)*data_shape[2]+shifts_h[ix,0]
#         end = st+data_shape[2]
#         print(st,end)
#         proj[:,:,st:end] = proj0
#         flat[:,:,st:end] = flat0
#         dark[:,:,st:end] = dark0
    
    
#     dxchange.write_tiff(proj[:,0],'/local/data/tmp/proj',overwrite=True)
#     dxchange.write_tiff(flat[:,0],'/local/data/tmp/flat',overwrite=True)
#     dxchange.write_tiff(dark[:,0],'/local/data/tmp/dark',overwrite=True)

#     # for checking
#     fproj = (proj-np.mean(dark,axis=0))/(np.mean(flat,axis=0)-np.mean(dark,axis=0)+1e-3)
#     print(f'{fproj.shape=}')
#     dxchange.write_tiff(fproj[:,0].astype('float32'),'/local/data/tmp/fproj',overwrite=True)



def main():   
    parser = argparse.ArgumentParser()
    parser.add_argument('--config', **config.SECTIONS['general']['config'])
    show_params     = config.MOSAIC_PARAMS
    extract_params  = config.MOSAIC_PARAMS
    sort_params     = config.MOSAIC_PARAMS
    tile_params     = config.MOSAIC_PARAMS
    shift_params    = config.MOSAIC_PARAMS
    test_stitch_params    = config.MOSAIC_PARAMS
    stitch_params   = config.MOSAIC_PARAMS

    cmd_parsers = [
        ('init',        init,           (),                 "Create configuration file"),
        ('status',      status,         show_params,        "Show the mosaic-cli status"),
        ('extract',     extract,        extract_params,     "Extract the mosaic tomography files"),
        ('sort',        sort,           sort_params,        "Sort the mosaic tomography files according to their tile location"),
        ('tile',        tile,           tile_params,        "Return the mosaic tiles"),
        ('shift',       shift,          shift_params,       "testing shift"),
        ('stitch',      stitch,         stitch_params,      "stitch all data"),
    ]

    subparsers = parser.add_subparsers(title="Commands", metavar='')

    for cmd, func, sections, text in cmd_parsers:
        cmd_params = config.Params(sections=sections)
        cmd_parser = subparsers.add_parser(cmd, help=text, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        cmd_parser = cmd_params.add_arguments(cmd_parser)
        cmd_parser.set_defaults(_func=func)

    args = config.parse_known_args(parser, subparser=True)

    # create logger
    logs_home = args.logs_home

    # make sure logs directory exists
    if not os.path.exists(logs_home):
        os.makedirs(logs_home)

    lfname = os.path.join(logs_home, 'mosaic_' + datetime.strftime(datetime.now(), "%Y-%m-%d_%H_%M_%S") + '.log')

    log.setup_custom_logger(lfname)
    log.debug("Started mosaic")
    log.warning('Saving log at %s' % lfname)
    
    try: 
        # load args from default (config.py) if not changed
        config.log_values(args)
        args._func(args)
        # undate meta5.config file
        sections = config.MOSAIC_PARAMS
        config.write(args.config, args=args, sections=sections)
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(1)

if __name__ == "__main__":
    main()
