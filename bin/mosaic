#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
.. module:: fileio.py
   :platform: Unix
   :synopsis: Reads the meta data of a tomographic hdf5 file and generates a table (rst) compatible with sphynx/readthelogs.

"""

import os
import sys
import time
import argparse
import numpy as np
import pandas as pd
import dxchange
import tomopy
import h5py
import matplotlib.pyplot as plt
from matplotlib.colors import NoNorm

from datetime import datetime

from mosaic import log
from mosaic import config
from mosaic import fileio
from mosaic import mosaic 
from mosaic import util

def init(args):
    if not os.path.exists(str(args.config)):
        config.write(str(args.config))
    else:
        raise RuntimeError("{0} already exists".format(args.config))

def status(args):
    config.show_config(args)

def extract(args):
    meta_dict = fileio.extract(args)
    for k, v in meta_dict.items():
        log.info("%s, %s, %s. Original file name: %s", k, meta_dict[k]['sample_x'], meta_dict[k]['sample_y'], meta_dict[k]['full_file_name'][0])

def sort(args):
    meta_dict = fileio.sort(args)
    for k, v in meta_dict.items():
        log.info("%s, %s, %s. Original file name: %s", k, meta_dict[k]['sample_x'], meta_dict[k]['sample_y'], meta_dict[k]['full_file_name'][0])

def tile(args):
    tile_dict, grid, data_shape, x_shift, y_shift = fileio.tile(args)
    log.info('image   size (x, y) in pixels: (%d, %d)' % (data_shape[2], data_shape[1]))
    log.info('mosaic shift (x, y) in pixels: (%d, %d)' % (x_shift, y_shift))
    log.warning('tile overlap (x, y) in pixels: (%d, %d)' % (data_shape[2]-x_shift, data_shape[1]-y_shift))

    index = [f'x_{num}' for num in range(grid.shape[0])]
    columns = [f'y_{num}' for num in range(grid.shape[1])]
    log.info('mosaic file name grid:\n%s' % pd.DataFrame(grid, columns=columns, index=index))

def shift(args):

    # read files grid and retrieve data sizes
    tile_dict, grid, data_shape, x_shift, y_shift = fileio.tile(args)

    log.info('image   size (x, y) in pixels: (%d, %d)' % (data_shape[2], data_shape[1]))
    log.info('mosaic shift (x, y) in pixels: (%d, %d)' % (x_shift, y_shift))
    log.warning('tile overlap (x, y) in pixels: (%d, %d)' % (data_shape[2]-x_shift, data_shape[1]-y_shift))

    columns = [f'x_{num}' for num in range(grid.shape[0])]
    index = [f'y_{num}' for num in range(grid.shape[0])]
    
    [ntiles_v,ntiles_h] = grid.shape

    multipliers = np.ones([ntiles_v,ntiles_h], dtype=np.float32)      
    # find shifts in horizontal direction
    shifts_h = np.zeros([ntiles_v,ntiles_h,2], dtype=np.float32)    
    for iy in range(ntiles_v):    
        for ix in range(ntiles_h-1):
            proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[iy,ix], proj=(0, data_shape[0], data_shape[0]//8))
            proj1, flat1, dark1, _, _ = dxchange.read_dx(grid[iy,ix+1], proj=(0, data_shape[0], data_shape[0]//8))
            norm0 = tomopy.normalize(proj0, flat0, dark0)
            norm1 = tomopy.normalize(proj1, flat1, dark1)
            wx = int((norm0.shape[2] - x_shift)*1)
            shift = mosaic.register_shift_sift(norm1[:,:,-wx:], norm0[:,:,:wx],args.threshold)

            shift = shift[~np.isnan(shift[:,0])]
            if (len(shift)==0):
                shift = np.array([[0,0]])
            shifts_h[iy,ix+1] = [np.median(shift[:,0]),np.median(wx-shift[:,1])]            
            #VN: tmp for Kaoumi dataset
            height = 350
            multipliers[iy,ix+1] = 1/(np.linalg.norm(norm1[:,data_shape[1]//2-height:data_shape[1]//2+height,-wx:])/np.linalg.norm(norm0[:,data_shape[1]//2-height:data_shape[1]//2+height,:wx]))
            print(multipliers)
    
    # find shifts in vertical direction    
    shifts_v = np.zeros([ntiles_v,ntiles_h,2], dtype=np.float32)    
    for ix in range(ntiles_h):
        for iy in range(ntiles_v-1):            
            proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[iy,ix], proj=(0, data_shape[0], data_shape[0]//8))
            proj1, flat1, dark1, _, _ = dxchange.read_dx(grid[iy+1,ix], proj=(0, data_shape[0], data_shape[0]//8))
            norm0 = tomopy.normalize(proj0, flat0, dark0)
            norm1 = tomopy.normalize(proj1, flat1, dark1)
            wy = int((norm0.shape[1] - y_shift)*1)
            shift = mosaic.register_shift_sift(norm0[:,-wy:,:], norm1[:,:wy,:],args.threshold)
            shift = shift[~np.isnan(shift[:,0])]
            if (len(shift)==0):
                shift = np.array([[0,0]])
            shifts_v[iy+1,ix] = [np.median(wy-shift[:,0]),np.median(shift[:,1])]
            #multipliers[iy+1,ix] = np.linalg.norm(norm0[:,-wy:,:])/np.linalg.norm(norm1[:,:wy,:])
    log.info('Horizontal shifts')
    log.info(shifts_h)
    log.info('Vertical shifts')
    log.info(shifts_v)

    shifts_h_fname, shifts_v_fname, multipliers_fname = fileio.service_fnames(args.mosaic_fname)

    # save shifts
    # VN:we can try to save them as txt or csv instead to be able to change manually at any time
    # log.info('save shifts as npy')
    # np.save(shifts_h_fname, shifts_h)
    # np.save(shifts_v_fname, shifts_v)
    # np.save(multipliers_fname, multipliers)

    # reshaping the array from 3D matrice to 2D matrice.
    fileio.write_array(shifts_h_fname, shifts_h)
    fileio.write_array(shifts_v_fname, shifts_v)
    fileio.write_array(multipliers_fname, multipliers)

    return shifts_h, shifts_v

def stitch(args):
    
    #VN:should come from command line
    # args.test = False # if test==True then 1 projection will be stitched and placed in /local/data/tmp/res_proj/r
    # args.chunk_size = 64 # number of projections for simultaneous processing

    shifts_h_fname, shifts_v_fname, multipliers_fname = fileio.service_fnames(args.mosaic_fname)

    # read shifts
    # shifts_h = np.load(shifts_h_fname)
    # shifts_v = np.load(shifts_h_fname)
    # multipliers = np.load(multipliers_fname)#*0+1

    # read shifts
    shifts_h    = fileio.read_array(shifts_h_fname)
    shifts_v    = fileio.read_array(shifts_v_fname)
    multipliers = fileio.read_array(multipliers_fname)

    #VN: For Kaoumi dataset shift is 230 and not 213
    #VN: we can organize some 'try' procedure for manual shift tuning..
    #VN: projection id to test shift should be in args
    shifts_h[np.abs((shifts_h-213))<1e-3]=230
    shifts_v[np.abs((shifts_h-77))<1e-3]=71

    #FDC: here we need to handle the case of h/v scan only (no tiles)
    # compute cumulative shifts
    cshifts_h = shifts_h[:,:,1]
    cshifts_v = shifts_v[:,:,0]
    cshifts_h[:,0] = np.cumsum(shifts_h[:,0,1]+shifts_v[:,0,1])
    cshifts_v[0,:] = np.cumsum(shifts_h[0,:,0]+shifts_v[0,:,0])
    cshifts_h = np.cumsum(cshifts_h,axis=1)
    cshifts_v = np.cumsum(cshifts_v,axis=0)
    cmultipliers = np.cumprod(multipliers,axis=1)
    print(cmultipliers)
    # retrieve sizes (could be optimized)
    _, grid, data_shape, _, _ = fileio.tile(args)
    [ntiles_v,ntiles_h] = grid.shape
    proj0, flat0, dark0, theta0, _ = dxchange.read_dx(grid[0,0], proj=(0, 1))


    proj_size = (ntiles_v*data_shape[1]-int(cshifts_v[-1].max()), 
        (ntiles_h*data_shape[2]-int(cshifts_h[-1].max()))//4*4)#make the width divisible by 4 to work with binning 2 at least
    
    
    if(args.test==True):
        # number of projections to test stitching
        nproj_to_stitch = 1
        # normalized array to be filled
        norm = np.zeros([nproj_to_stitch,*proj_size],dtype='float32')        
    else:
        nproj_to_stitch = data_shape[0]

    # mosaic_fname = os.path.join(args.folder_name, 'tmp', 'mosaic.h5')
    with h5py.File(args.mosaic_fname,'w') as fid:
        # init output arrays
        #VN: add metadata with dxwriter
        proj = fid.create_dataset('/exchange/data', (nproj_to_stitch,*proj_size),dtype=proj0.dtype, chunks = (1,*proj_size))
        flat = fid.create_dataset('/exchange/data_white', (1,*proj_size),dtype=flat0.dtype, chunks = (1,*proj_size))
        dark = fid.create_dataset('/exchange/data_dark', (1,*proj_size),dtype=dark0.dtype, chunks = (1,*proj_size))
        theta = fid.create_dataset('/exchange/theta', data = theta0/np.pi*180)
        
        # stitch projections by chunks
        for ichunk in range(int(np.ceil(nproj_to_stitch/args.chunk_size))):
            st_chunk = ichunk*args.chunk_size
            end_chunk = min((ichunk+1)*args.chunk_size,nproj_to_stitch)
            if(args.test==True):
                st_chunk = args.proj
                end_chunk = args.proj+1
            
            log.info('Processing projections: %d - %d' % (st_chunk, end_chunk))
            for iy in range(ntiles_v):    
                for ix in range(ntiles_h):
                    # VN: no need to read flat and dark fields for each chunk, should we use h5py[].. instead?
                    proj0, flat0, dark0, _, _ = dxchange.read_dx(grid[iy,ix], proj=(st_chunk,end_chunk))
                    
                    # VN: tmp for Kaoumi data
                    proj0 = (np.float32(proj0)*cmultipliers[iy,ix]).astype(proj0.dtype)


                    # define index in x for proj (filling from the right side)
                    st_x0 = int(np.round(proj.shape[2]-(ix+1)*data_shape[2]+cshifts_h[iy,ix]))
                    end_x0 = st_x0+data_shape[2]            
                    
                    # define index in y for proj (filling from the top side)
                    st_y0 = int(np.round(iy*data_shape[1]-cshifts_v[iy,ix]))
                    end_y0 = st_y0+data_shape[1]            
                    
                    # crop to the proj size 
                    st_y = max(st_y0,0)
                    st_x = max(st_x0,0)
                    end_y = min(end_y0,proj.shape[1])
                    end_x = min(end_x0,proj.shape[2])
                                        
                    # define index in x for proj0
                    st_x0 = st_x-st_x0
                    end_x0 = proj0.shape[2]+end_x-end_x0
                    
                    # define index in x for proj0
                    st_y0 = st_y-st_y0                    
                    end_y0 = proj0.shape[1]+end_y-end_y0
                    
                    # fill array part
                    proj[st_chunk:end_chunk,st_y:end_y,st_x:end_x] = proj0[:,st_y0:end_y0,st_x0:end_x0]
                    print(f'{grid[iy,ix]=} {ix=} {iy=} {dark0.shape=}')
                    if(ichunk==0): # flat and dark field can be filled once (VN: maybe we can move this code out of the loop)
                        flat[:,st_y:end_y,st_x:end_x] = np.mean(flat0[:,st_y0:end_y0,st_x0:end_x0],axis=0)
                        dark[:,st_y:end_y,st_x:end_x] = np.mean(dark0[:,st_y0:end_y0,st_x0:end_x0],axis=0)
                    
                    if(args.test==True):                
                        # fill the normalized array part
                        norm[0,st_y:end_y,st_x:end_x] = tomopy.normalize(proj0[0,st_y0:end_y0,st_x0:end_x0], 
                            flat0[:,st_y0:end_y0,st_x0:end_x0], dark0[:,st_y0:end_y0,st_x0:end_x0])                
                        # plot lines arround borders (not necessary in future)
                        norm[0,min(max(st_y-16,0),proj.shape[1]-1),st_x:end_x]=0
                        norm[0,min(max(st_y+16,0),proj.shape[1]-1),st_x:end_x]=0
                        norm[0,min(max(end_y-16,0),proj.shape[1]-1),st_x:end_x]=0
                        norm[0,min(max(end_y+16,0),proj.shape[1]-1),st_x:end_x]=0
                        
                        norm[0,st_y:end_y,min(max(st_x-16,0),proj.shape[2]-1)]=0
                        norm[0,st_y:end_y,min(max(st_x+16,0),proj.shape[2]-1)]=0
                        norm[0,st_y:end_y,min(max(end_x-16,0),proj.shape[2]-1)]=0
                        norm[0,st_y:end_y,min(max(end_x+16,0),proj.shape[2]-1)]=0

    log.info('Stitched h5 file is saved as %s' % args.mosaic_fname)
    if(args.test==True): 
        mosaic_folder = os.path.dirname(args.mosaic_fname)
        mosaic_test_fname = os.path.join(mosaic_folder, 'projection')
        dxchange.write_tiff_stack(norm, mosaic_test_fname,overwrite=True)
        log.info('Test results are saved to %s' % mosaic_test_fname)



def main():   
    parser = argparse.ArgumentParser()
    parser.add_argument('--config', **config.SECTIONS['general']['config'])
    show_params     = config.MOSAIC_PARAMS
    extract_params  = config.MOSAIC_PARAMS
    sort_params     = config.MOSAIC_PARAMS
    tile_params     = config.MOSAIC_PARAMS
    shift_params    = config.MOSAIC_PARAMS
    stitch_params   = config.STITCH_PARAMS

    cmd_parsers = [
        ('init',        init,           (),                 "Create configuration file"),
        ('status',      status,         show_params,        "Show the mosaic-cli status"),
        ('extract',     extract,        extract_params,     "Extract the mosaic tomography files"),
        ('sort',        sort,           sort_params,        "Sort the mosaic tomography files according to their tile location"),
        ('tile',        tile,           tile_params,        "Return the mosaic tiles"),
        ('shift',       shift,          shift_params,       "testing shift"),
        ('stitch',      stitch,         stitch_params,      "stitch all data"),
    ]

    subparsers = parser.add_subparsers(title="Commands", metavar='')

    for cmd, func, sections, text in cmd_parsers:
        cmd_params = config.Params(sections=sections)
        cmd_parser = subparsers.add_parser(cmd, help=text, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        cmd_parser = cmd_params.add_arguments(cmd_parser)
        cmd_parser.set_defaults(_func=func)

    args = config.parse_known_args(parser, subparser=True)

    # create logger
    logs_home = args.logs_home

    # make sure logs directory exists
    if not os.path.exists(logs_home):
        os.makedirs(logs_home)

    lfname = os.path.join(logs_home, 'mosaic_' + datetime.strftime(datetime.now(), "%Y-%m-%d_%H_%M_%S") + '.log')

    log.setup_custom_logger(lfname)
    log.debug("Started mosaic")
    log.warning('Saving log at %s' % lfname)
    
    mosaic_home = os.path.join(args.folder_name, 'mosaic')
    if not os.path.exists(mosaic_home):
        os.makedirs(mosaic_home)    
    
    args.mosaic_fname = os.path.join(mosaic_home, 'mosaic.h5')

    try: 
        # load args from default (config.py) if not changed
        config.log_values(args)
        args._func(args)
        # undate meta5.config file
        sections = config.MOSAIC_PARAMS
        config.write(args.config, args=args, sections=sections)
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(1)

if __name__ == "__main__":
    main()
